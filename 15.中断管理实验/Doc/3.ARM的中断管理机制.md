在ARM Cortex-M系列处理器上，所有中断都采用中断向量表的方式进行处理，即当一个中断触发时，处理器将直接判定是哪个中断源，然后直接跳转到相应的固定位置进行处理。而在ARM7、ARM9中，一般是先跳转进入IRQ入口，然后再由软件进行判断是哪个中断源触发，获得了相对应的中断服务例程入口地址 后，再进行后续的中断处理。ARM7、ARM9的好处在于，所有中断它们都有统一的入口地址，便于OS的统一管理。而ARM Cortex- M系列处理器则恰恰相反，每个中断服务例程必须排列在一起放在统一的地址上（这个地址必须要设置到NVIC的中断向量偏移寄存器中）。

ARM不同处理器架构的中断处理机制差异，其核心在于**中断入口的集中性与分散性**以及**中断响应流程的硬件/软件分工**。以下从技术原理和设计逻辑角度进行拆解：

---

### **1. ARM7/ARM9：统一入口的软件调度模式**
- **中断入口单一化**  
  ARM7/ARM9要求所有外部中断（IRQ）共享同一个固定入口地址（如`0x00000018`）。无论中断源是定时器、串口还是其他外设，触发中断后CPU都会先跳转到该统一入口地址。
- **软件判断中断源**  
  在IRQ入口处，需通过软件（通常是中断控制器驱动）读取**中断挂起寄存器**（如VIC或GIC的寄存器），解析具体是哪个中断源触发，再根据预设的映射表查询对应的中断服务例程（ISR）地址。  
  **伪代码示例**：  
  ```assembly
  IRQ_Handler:
      LDR r0, =VIC_VECTOR_ADDR   ; 读取中断控制器提供的ISR地址
      LDR pc, [r0]               ; 跳转到实际ISR
  ```
- **OS管理优势**  
  统一入口便于操作系统集中管理中断上下文保存/恢复、优先级调度等通用逻辑，适合复杂任务系统。但**额外开销**明显：软件查表增加延迟（通常10-20时钟周期），中断响应时间（Latency）较长。

---

### **2. ARM Cortex-M：向量化的硬件直连模式**
- **向量表分散化**  
  Cortex-M的NVIC要求每个中断源在**中断向量表**中独占一项（4字节），存储其ISR的入口地址。向量表默认位于Flash起始位置（如`0x08000000`），但可通过**VTOR寄存器**（地址`0xE000ED08`）重定位到RAM或其他地址。
- **硬件自动跳转**  
  中断触发时，NVIC硬件自动完成以下动作：
  1. 根据中断号（IRQn）计算向量偏移量：`基地址 + 4 × IRQn`。
  2. 直接从中断向量表加载ISR地址到PC寄存器。
  3. 跳转执行ISR，全程无软件干预。
  **示例**：  
  若USART1中断号为37，则其ISR地址位于 `VTOR基址 + 37×4`。
- **实时性优势与OS适配挑战**  
  **优势**：硬件自动跳转将中断响应延迟降至1-2时钟周期，满足实时系统需求。  
  **挑战**：每个ISR需独立编写且地址必须预先填入向量表，操作系统需通过VTOR动态修改向量表以实现任务级中断管理（如FreeRTOS的`vTaskSwitchContext`）。

> 另外，ARM Cortex-M NVIC支持中断嵌套功能：当一个中断触发并且系统进行响应时，处理器硬件会将当前运行的部分上下文寄存器自动压入中断栈中，这部分的寄存器包括PSR，R0，R1，R2，R3以及R12寄存器。当系统正在服务一个中断时，如果有一个更高优先级的中断触发，那么处理器同样的会打断当前运行的中断服务例程，然后把老的中断服务例程上下文的PSR，R0，R1，R2，R3和R12寄存器自动保存到中断栈中。这些部分上下文寄存器保存到中断栈的行为完全是硬件行为，这一点是与其他ARM处理器最大的区别（以往都需要依赖于软件保存上下文）。

---

### **3. 关键差异对比**
| **特性**                | **ARM7/ARM9**               | **ARM Cortex-M**               |
|-------------------------|----------------------------|--------------------------------|
| **中断入口**            | 单一固定入口（IRQ/FIQ）    | 向量表分散入口（每中断独立）  |
| **中断源判定**          | 软件读取寄存器             | 硬件自动索引向量表            |
| **延迟来源**            | 软件查表+跳转              | 硬件直跳（仅内存访问延迟）    |
| **向量表灵活性**        | 不可重定位                 | 支持VTOR重定向到RAM/Flash     |
| **适用场景**            | 通用OS（如Linux）          | 实时系统（如μC/OS-II、Zephyr）|

---

### **4. 设计取舍的深层逻辑**
- **实时性 vs. 灵活性**  
  Cortex-M的向量化中断牺牲了统一入口的简洁性，换取亚微秒级响应，适合工业控制、自动驾驶等实时场景。而ARM7/ARM9的软件调度更适应需要动态加载驱动或复杂中断路由的通用OS。
- **硬件进化**  
  NVIC集成于Cortex-M内核，通过硬件寄存器（如VTOR、IPR）管理优先级和重定位，取代了外部中断控制器（如ARM7的VIC），减少芯片面积和功耗。
- **OS适配演进**  
  现代RTOS通过动态修改RAM中的向量表（如`memcpy(_RAM_VECTOR, _FLASH_VECTOR, size)` + `SCB->VTOR = _RAM_VECTOR`）实现任务级中断管理，平衡了实时性与灵活性。

---

### **总结**  
**ARM7/ARM9以软件调度为代价换取中断入口的统一性，便于OS抽象；而Cortex-M以硬件向量化为核心，牺牲入口统一性但极致优化实时性**。两者差异本质上是不同应用场景下对中断响应效率与系统可管理性的权衡结果。理解这一设计哲学，才能合理选择架构并优化中断处理逻辑。