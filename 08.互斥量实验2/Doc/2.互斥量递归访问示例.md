以下是一个简洁且完整的uC/OS-III互斥量使用示例，适用于`app.c`文件。此程序模拟两个任务（高/低优先级）通过互斥量安全访问共享串口资源，重点演示**递归访问**和**优先级继承**机制。

---

### 示例代码（`app.c`）
```c
#include "includes.h"  // 包含uC/OS-III头文件

// 定义任务优先级
#define TASK_HIGH_PRIO  4  // 高优先级任务
#define TASK_LOW_PRIO    5  // 低优先级任务

// 任务栈和控制块
OS_TCB    tcb_high, tcb_low;
CPU_STK   stk_high[128], stk_low[128];

// 共享资源：串口互斥量
OS_MUTEX  uart_mutex;

// 高优先级任务函数
void TaskHigh(void *p_arg) {
    OS_ERR err;
    while (1) {
        printf("TaskHigh: 等待串口访问权...\n");
        OSMutexPend(&uart_mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);  // 请求互斥量
        printf("TaskHigh: 开始操作串口（临界区）\n");
        OSTimeDlyHMSM(0, 0, 1, 0, OS_OPT_TIME_DLY, &err);  // 模拟操作耗时
        OSMutexPost(&uart_mutex, OS_OPT_POST_NONE, &err);   // 释放互斥量
        printf("TaskHigh: 释放串口，挂起2秒\n");
        OSTimeDlyHMSM(0, 0, 2, 0, OS_OPT_TIME_DLY, &err);
    }
}

// 低优先级任务函数（演示递归访问）
void TaskLow(void *p_arg) {
    OS_ERR err;
    while (1) {
        OSMutexPend(&uart_mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);  // 首次获取
        printf("TaskLow: 首次获取互斥量（嵌套计数器=1）\n");
        
        // 嵌套调用：递归获取同一互斥量
        OSMutexPend(&uart_mutex, 0, OS_OPT_PEND_BLOCKING, NULL, &err);  // 递归获取
        printf("TaskLow: 递归获取互斥量（嵌套计数器=2）\n");
        
        OSTimeDlyHMSM(0, 0, 3, 0, OS_OPT_TIME_DLY, &err);  // 模拟长时操作
        OSMutexPost(&uart_mutex, OS_OPT_POST_NONE, &err);   // 释放一次（计数器=1）
        OSMutexPost(&uart_mutex, OS_OPT_POST_NONE, &err);   // 再释放一次（计数器=0）
        printf("TaskLow: 完全释放互斥量\n");
        OSTimeDlyHMSM(0, 0, 4, 0, OS_OPT_TIME_DLY, &err);   // 挂起等待
    }
}

int main(void) {
    OS_ERR err;

    // 初始化系统
    OSInit(&err);

    // 创建互斥量（启用优先级继承）
    OSMutexCreate(&uart_mutex, "UART Mutex", &err);  // 

    // 创建任务
    OSTaskCreate(&tcb_high, "High Task", TaskHigh, NULL, TASK_HIGH_PRIO, 
                 &stk_high[127], 128, 0, 0, NULL, OS_OPT_TASK_STK_CHK, &err);
    OSTaskCreate(&tcb_low, "Low Task", TaskLow, NULL, TASK_LOW_PRIO, 
                 &stk_low[127], 128, 0, 0, NULL, OS_OPT_TASK_STK_CHK, &err);

    // 启动系统
    OSStart(&err);
    return 0;
}
```

---

### 关键机制说明
1. **递归访问**  
   `TaskLow`两次调用`OSMutexPend()`获取同一互斥量，内部计数器从`1`→`2`。释放时需调用两次`OSMutexPost()`使计数器归零，否则资源被永久锁定。

2. **优先级继承**  
   当`TaskHigh`（高优先级）等待`TaskLow`（低优先级）持有的互斥量时，`TaskLow`的优先级会临时提升至`TASK_HIGH_PRIO`，确保其尽快释放资源。

3. **阻塞式等待**  
   `OS_OPT_PEND_BLOCKING`参数使任务在互斥量不可用时挂起，避免忙等待消耗CPU。

---

### 输出效果示例
```plaintext
TaskLow: 首次获取互斥量（嵌套计数器=1）
TaskLow: 递归获取互斥量（嵌套计数器=2）
TaskHigh: 等待串口访问权...  # 此时TaskLow优先级临时提升至4
TaskLow: 完全释放互斥量     # 释放后TaskLow优先级恢复为5
TaskHigh: 开始操作串口（临界区）
TaskHigh: 释放串口，挂起2秒
```

---

### 注意事项
1. **释放次数匹配**  
   递归获取时，`OSMutexPost()`调用次数必须与`OSMutexPend()`相等，否则导致死锁。

2. **禁止在中断中使用**  
   互斥量API（如`OSMutexPend()`）不可在中断服务程序（ISR）内调用。

3. **优先级设计**  
   持有互斥量的任务优先级应尽量高，以减少阻塞时间；避免在临界区内修改任务优先级。

> 此示例可直接集成到uC/OS-III工程中运行。实际使用时需根据硬件初始化串口（如`UART_Init()`），此处省略以保持简洁性。