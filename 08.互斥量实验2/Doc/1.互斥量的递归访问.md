在uC/OS-III中，**互斥量的递归访问（Recursive Access）** 是指同一个任务可以多次获取（持有）同一个互斥量而不会导致自身挂起或死锁的特性。这一机制通过内部计数器实现，是互斥量区别于普通二值信号量的核心功能之一。以下是详细解析：

---

### 一、递归访问的实现机制
1. **嵌套计数器（`OwnerNestingCtr`）**  
   互斥量控制块中有一个关键变量 `OwnerNestingCtr`，用于记录当前任务持有该互斥量的次数：
   - **首次获取**：任务成功获取互斥量时，计数器置为 `1`，互斥量状态转为闭锁（其他任务无法获取）。
   - **递归获取**：若任务已持有互斥量，再次调用 `OSMutexPend()` 时，计数器**递增**（如从 `1` 变为 `2`），任务不会被阻塞。
   - **释放互斥量**：每次调用 `OSMutexPost()` 时，计数器**递减**，仅当计数器归零时，互斥量才真正释放（状态转为开锁），其他任务才能获取。

2. **递归死锁的避免**  
   普通二值信号量若被任务递归获取，第二次请求会因资源不可用导致任务主动挂起，形成死锁。而互斥量的递归特性允许同一任务多次持有，避免此问题。

---

### 二、递归访问的应用场景
递归访问适用于以下情况：
1. **嵌套函数调用**  
   任务在多个层级的函数中访问同一临界资源（如先调用函数A，A内部再调用函数B，二者均需操作同一硬件外设），无需重复获取/释放锁，简化代码逻辑。
2. **复杂资源管理**  
   当任务需多次修改资源状态（如分阶段初始化设备），递归持有互斥量可确保操作原子性，避免中间状态被其他任务破坏。

---

### 三、递归访问的注意事项
1. **释放次数必须匹配**  
   任务释放互斥量的次数**必须等于获取次数**，否则计数器无法归零，导致资源永久锁死（其他任务永久阻塞）。
   ```c
   void Task() {
       OSMutexPend(&mutex);  // 计数器=1
       FunctionA();          // 内部再次获取互斥量（计数器=2）
       OSMutexPost(&mutex);  // 计数器=1（未完全释放！）
       // 遗漏一次 OSMutexPost()，资源未释放！
   }
   ```

2. **与优先级继承的协同**  
   - 递归期间，若高优先级任务请求该互斥量，持有任务会**继承高优先级**（优先级继承机制），但仅当计数器归零释放时，优先级才会恢复。
   - **禁止在持有互斥量时修改任务优先级**，否则破坏优先级继承逻辑。

3. **中断上下文禁用**  
   互斥量（含递归操作）**不能在中断服务函数（ISR）中使用**，因为其优先级继承机制仅适用于任务调度环境。

---

### 四、示例场景：串口资源的递归保护
```c
void UART_SendPacket(char* data) {
    OSMutexPend(&uart_mutex);  // 首次获取（计数器=1）
    UART_SendBytes(data);      // 发送数据
    OSMutexPost(&uart_mutex);  // 释放（计数器=0）
}

void UART_SendBytes(char* data) {
    OSMutexPend(&uart_mutex);  // 递归获取（计数器=2）
    // 逐字节发送（临界操作）
    OSMutexPost(&uart_mutex);  // 释放（计数器=1）
}
```
此例中，`UART_SendPacket` 调用 `UART_SendBytes` 时不会死锁，且串口资源始终被安全隔离。

---

### 总结
uC/OS-III 互斥量的递归访问通过**嵌套计数器**实现，允许同一任务多次持有同一互斥量，解决了嵌套函数中资源保护的死锁问题。使用时需严格保证**获取/释放次数匹配**，并避免在持有锁时修改优先级或于中断中操作。这一特性在复杂资源管理场景中至关重要，但需谨慎设计以避免资源泄漏。