以下通过一个具体示例说明UCOSIII中**同优先级任务的时间片轮转调度机制**，结合代码和现象分步解析：

---

### 📊 **场景设定**
- **任务配置**：创建两个优先级相同的任务（优先级=4），分别通过串口打印不同字符序列。  
- **时间片长度**：每个任务分配**10ms时间片**（假设系统时钟节拍为1kHz，1个节拍=1ms）。  
- **关键代码**：  
  ```c
  // 启用时间片轮转（os_cfg.h中配置）
  #define OS_CFG_SCHED_ROUND_ROBIN_EN  1u
  
  // 主函数初始化
  int main(void) {
      OS_ERR err;
      // 初始化UCOSIII
      OSInit(&err);
      // 启用时间片轮转，默认时间片=10个节拍（10ms）
  #if OS_CFG_SCHED_ROUND_ROBIN_EN
      OSSchedRoundRobinCfg(DEF_ENABLED, 10, &err); 
  #endif
      // 创建任务（优先级均为4）
      OSTaskCreate(&Task1_TCB, "Task1", task1_func, 0, 4, ... , 10, ...); // 时间片10ms
      OSTaskCreate(&Task2_TCB, "Task2", task2_func, 0, 4, ... , 10, ...); // 时间片10ms
      OSStart(&err); // 启动调度器
  }
  ```

---

### 🔄 **任务函数行为**
#### **任务1**：打印 `0123456789`，循环5次后延时1秒  
```c
void task1_func(void *p_arg) {
    while(1) {
        for (int i=0; i<5; i++) {
            printf("Task1:0123456789\n"); // 执行耗时约2ms/次
        }
        OSTimeDlyHMSM(0,0,1,0, OS_OPT_TIME_DLY, &err); // 阻塞1秒
    }
}
```

#### **任务2**：打印 `9876543210`，循环5次后延时1秒  
```c
void task2_func(void *p_arg) {
    while(1) {
        for (int i=0; i<5; i++) {
            printf("Task2:9876543210\n"); // 执行耗时约2ms/次
        }
        OSTimeDlyHMSM(0,0,1,0, OS_OPT_TIME_DLY, &err);
    }
}
```

---

### ⏱️ **调度过程详解**
1. **初始状态**：  
   - 任务1和任务2均处于**就绪状态**，按创建顺序排队：任务1 → 任务2（FIFO队列）。

2. **时间片消耗**：  
   - 任务1先运行，**每打印1次消耗2ms**。  
   - 当累计运行 **10ms（时间片耗尽）**：  
     - 系统在时钟中断中检查到时间片归零，将任务1移入队尾，任务2移至队首。  
     - 任务2开始运行，同样获得10ms时间片。

3. **主动让出时间片**：  
   若任务2在运行3ms后调用 `OSSchedRoundRobinYield(&err)`：  
   - 立即切换回任务1，任务1**剩余时间片=7ms**继续执行。

4. **阻塞时的调度**：  
   - 若任务1在打印3次后（耗时6ms）调用 `OSTimeDlyHMSM()` 进入阻塞：  
     - 剩余4ms时间片**丢弃**，任务2立即开始运行。  
     - 任务1唤醒后重新获得完整10ms时间片。

---

### 🔍 **实验现象观察**
通过串口输出可看到：  
```
Task1:0123456789  // 任务1第1次打印
Task1:0123456789  // 任务1第2次打印
...（共5次，耗时10ms内）
Task2:9876543210  // 任务2开始打印（时间片切换）
Task2:9876543210
...
```
- **启用时间片时**：任务1和任务2的输出**交替出现**（互相打断）。  
- **未启用时间片时**：任务1完整打印5次后才轮到任务2，**无交替现象**。

---

### ⚠️ **关键注意事项**
1. **时间片长度调试**：  
   - 过长（如100ms）：低响应性，同优先级任务等待延迟；  
   - 过短（如1ms）：频繁切换增加系统开销。  
   **建议**：根据任务最坏执行时间（WCET）设定，例如任务单次循环需8ms，则时间片≥8ms。

2. **适用场景限制**：  
   - 时间片轮转**仅在同优先级任务间生效**；  
   - 高优先级任务就绪时立即抢占（无视时间片）。

---

通过此案例可直观理解：**时间片轮转通过队列移位+时间片计数实现同优先级任务的公平调度**，结合抢占机制保障实时性。