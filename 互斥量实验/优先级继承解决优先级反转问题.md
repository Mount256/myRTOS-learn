**优先级继承（Priority Inheritance）如何解决优先级反转问题**？核心思想是：**当高优先级任务因锁被阻塞时，内核临时提升持有该锁的低优先级任务的优先级，使其免受中优先级任务干扰，从而加速锁的释放。**

---

### 原始问题场景回顾（未启用优先级继承）：
1. **Task_L**（低）持有锁 → **Task_H**（高）请求锁被阻塞 → **Task_M**（中）抢占 Task_L → Task_H 被迫等待 Task_M 执行完成  
   **结果**：Task_H 的等待时间被无限拉长。

---

### 启用优先级继承后的解决流程：
#### 阶段 1: Task_L 获取锁（不变）
- **t0**: Task_L（优先级 30）获取互斥锁 `Mutex_A`，进入临界区。

#### 阶段 2: Task_H 请求锁被阻塞 → **触发优先级继承！**
- **t1**:  
  - Task_H（优先级 10）就绪并抢占 Task_L。  
  - Task_H 请求 `Mutex_A`，发现锁被 Task_L 持有。  
- **内核关键操作（核心！）**：  
  ```c
  // 伪代码展示内核行为
  if (高优先级任务因锁阻塞) {
      // 临时提升锁持有者的优先级
      if (Task_L.original_priority > Task_H.priority) { // 30 > 10？不成立！此处应为比较逻辑相反
          // 正解：比较原始优先级（数值越大优先级越低）
          if (Task_L.original_priority < Task_H.priority) { // 30 > 10 → 数值30>10但优先级30<10
              // 继承发生：将Task_L的当前优先级提升至Task_H的优先级
              Task_L.current_priority = Task_H.priority; // 10
              // 更新就绪表：将Task_L从优先级30位置移到优先级10位置
              OSRdyTbl[30/8] &= ~(1 << (30%8)); // 清除原优先级位
              OSRdyTbl[10/8] |=  (1 << (10%8)); // 设置新优先级位
          }
      }
  }
  ```  
- **结果**:  
  - Task_L **优先级临时提升至 10**（与 Task_H 相同）  
  - Task_H 进入阻塞态，等待锁释放  

> ✅ **关键点**：此时 Task_L 的优先级 = 10，不再是原来的低优先级（30）

#### 阶段 3: Task_M 就绪 → **无法再抢占 Task_L！**
- **t2**:  
  - Task_M（优先级 20）变为就绪状态  
- **调度器决策**:  
  - 当前就绪任务：Task_L（优先级 10），Task_M（优先级 20）  
  - **比较规则**：数值越小优先级越高  
    → 优先级 10 > 优先级 20  
    → **Task_L 继续运行！**  
- **结果**:  
  - Task_M **无法抢占** Task_L（因其优先级低于 Task_L 的临时优先级 10）  
  - Task_L **持续占有 CPU** 执行临界区代码  

#### 阶段 4: Task_L 释放锁 → **优先级恢复 + 唤醒 Task_H**
- **t3**:  
  - Task_L 完成临界区操作，释放锁 `OSMutexPost(Mutex_A)`  
- **内核关键操作**:  
  ```c
  // 释放锁时检查优先级继承状态
  if (Task_L 因继承被提升过优先级) {
      // 恢复原始优先级
      Task_L.current_priority = Task_L.original_priority; // 30
      // 更新就绪表
      OSRdyTbl[10/8] &= ~(1 << (10%8)); // 清除优先级10
      OSRdyTbl[30/8] |=  (1 << (30%8)); // 恢复优先级30
      // 唤醒等待队列中最高优先级任务（Task_H）
      OS_WakeHighestPriorityTask(Mutex_A.wait_queue);
  }
  ```  
- **结果**:  
  1. Task_L 优先级恢复为 30  
  2. Task_H（优先级 10）被唤醒，获得锁并开始执行  
  3. 调度器立即切换至 Task_H（因它优先级最高）  

#### 阶段 5: 正常调度恢复
- Task_H 执行临界区代码（持有锁）  
- 完成后释放锁 → 调度器按正常优先级调度后续任务  

---

### 关键效果对比：
| **场景**               | Task_H 等待时间                 | 系统行为                 |
|------------------------|--------------------------------|--------------------------|
| **无优先级继承**       | Task_M执行时间 + Task_L剩余时间 | Task_H 被中优先级阻塞    |
| **启用优先级继承**     | **仅 Task_L 剩余执行时间**      | Task_M 无法中断锁持有者 |

> 📊 **性能提升**：Task_H 的阻塞时间从 `T_taskM + T_taskL_remain` 缩短为 `T_taskL_remain`

---

### 优先级继承的核心逻辑：
1. **触发条件**：  
   - 高优先级任务因请求**被持有的互斥锁（Mutex）** 而阻塞  

2. **继承动作**：  
   - 内核临时将**锁持有者的优先级**提升至**与该阻塞任务相同**  

3. **防干扰效果**：  
   - 阻止任何**优先级低于继承值的任务**（如 Task_M）抢占锁持有者  

4. **恢复机制**：  
   - 锁释放时自动恢复锁持有者的原始优先级  
   - 唤醒等待队列中优先级最高的任务  

---

### 在 uC/OS 中的具体实现：
```c
// 创建支持优先级继承的互斥锁（注意参数）
OS_EVENT *OSMutexCreate(INT8U prio,    // Ceiling优先级（>=可能等待任务的最高优先级）
                        OS_ERR *err);

// 请求锁（隐含继承逻辑）
void OSMutexPend(OS_EVENT *p_event, 
                 INT32U timeout, 
                 OS_ERR *err); 

// 释放锁（隐含恢复逻辑）
void OSMutexPost(OS_EVENT *p_event);
```

> ⚠️ **必须用 Mutex 而非普通信号量**：只有 uC/OS 的 `OSMutexPend/Post()` 支持优先级继承，二进制信号量无此功能！

---

### 为什么能根治优先级反转？
通过**动态改写优先级规则**打破死循环：  
当锁被低优先级任务持有时，内核临时赋予它“高优先级身份”，使**中优先级任务失去剥夺权**，保证锁持有者能无干扰地快速完成工作，从根本上消除了中优先级任务间接阻塞高优先级任务的可能性。