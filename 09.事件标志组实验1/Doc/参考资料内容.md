内容来自：[【UCOSIII】事件标志组](https://blog.csdn.net/qq_38410730/article/details/80916936)

## 等待一个事件标志组

等待一个事件标志组需要调用函数OSFlagPend()，函数原型如下：

```c
OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,                            //指向事件标志组
                      OS_FLAGS      flags,                            //bit序列
                      OS_TICK       timeout,                        //指定等待事件标志组的超时时间(时钟节拍数)
                      OS_OPT        opt,                            //决定任务等待的条件
                      CPU_TS       *p_ts,                            //指向一个时间戳
                      OS_ERR       *p_err)
{
    CPU_BOOLEAN   consume;
    OS_FLAGS      flags_rdy;
    OS_OPT        mode;
    OS_PEND_DATA  pend_data;
    CPU_SR_ALLOC();
 
    if ((opt & OS_OPT_PEND_FLAG_CONSUME) != (OS_OPT)0) {    /* See if we need to consume the flags                    */
        consume = DEF_TRUE;
    } else {
        consume = DEF_FALSE;
    }
 
    if (p_ts != (CPU_TS *)0) {
       *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
    }
 
    mode = opt & OS_OPT_PEND_FLAG_MASK;
    CPU_CRITICAL_ENTER();
    switch (mode) {
        case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
             if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
                 }
                 OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
                 if (p_ts != (CPU_TS *)0) {
                    *p_ts  = p_grp->TS;
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
                         CPU_CRITICAL_EXIT();
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
                         return ((OS_FLAGS)0);
                     }
                 }
                                                            
                 OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
                 OS_FlagBlock(&pend_data,
                              p_grp,
                              flags,
                              opt,
                              timeout);
                 OS_CRITICAL_EXIT_NO_SCHED();
             }
             break;
 
        case OS_OPT_PEND_FLAG_SET_ANY:
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
             if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
                 }
                 OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
                 if (p_ts != (CPU_TS *)0) {
                    *p_ts  = p_grp->TS;
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
                         CPU_CRITICAL_EXIT();
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
                         return ((OS_FLAGS)0);
                     }
                 }
                                                            
                 OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
                 OS_FlagBlock(&pend_data,
                              p_grp,
                              flags,
                              opt,
                              timeout);
                 OS_CRITICAL_EXIT_NO_SCHED();
             }
             break;
 
        default:
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
 
    OSSched();                                              /* Find next HPT ready to run                             */
 
    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* We got the vent flags                                  */
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
             }
            *p_err = OS_ERR_NONE;
             break;
 
        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
             }
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_PEND_ABORT;
             return ((OS_FLAGS)0);
 
        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = (CPU_TS  )0;
             }
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_TIMEOUT;
             return ((OS_FLAGS)0);
 
        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
             }
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OBJ_DEL;
             return ((OS_FLAGS)0);
 
        default:
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATUS_INVALID;
             return ((OS_FLAGS)0);
    }
 
    flags_rdy = OSTCBCurPtr->FlagsRdy;
    if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
        switch (mode) {
            case OS_OPT_PEND_FLAG_SET_ALL:
            case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
                 p_grp->Flags &= ~flags_rdy;
                 break;
 
            default:
                 CPU_CRITICAL_EXIT();
                *p_err = OS_ERR_OPT_INVALID;
                 return ((OS_FLAGS)0);
        }
    }
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
    return (flags_rdy);
}
```

flags：bit序列，任务需要等待事件标志组的哪个位就把这个序列对应的位置1，根据设置这个序列可以是8bit、16bit或者32bit。比如任务需要等待时间标志组的bit0和bit1时（无论是等待置位还是清零），flag是的值就为0X03。

opt：决定任务等待的条件是所有标志置位、所有标志清零、任意一个标志置位还是任意一个标志清零，具体的定义如下：

```c
OS_OPT_PEND_FLAG_CLR_ALL：等待事件标志组所有的位清零；
OS_OPT_PEND_FLAG_CLR_ANY：等待事件标志组中任意一个标志清零；
OS_OPT_PEND_FLAG_SET_ALL：等待事件标志组中所有的位置位；
OS_OPT_PEND_FLAG_SET_ANY：等待事件标志组中任意一个标志置位。
```

调用上面四个选项的时候还可以搭配下面三个选项：

```c
OS_OPT_PEND_FLAG_CONSUME：用来设置是否继续保留该事件标志的状态；
OS_OPT_PEND_NON_BLOCKING：标志组不满足条件时不挂起任务；
OS_OPT_PEND_BLOCKING：标志组不满足条件时挂起任务。
```

这里应该注意选项OS_OPT_PEND_FLAG_CONSUME的使用方法，如果希望事件标志组的任意一个标志置位，并在满足条件后将对应的标志清零，那么就可以搭配使用选项OS_OPT_PEND_FLAG_CONSUME。

## 向事件标志组发布标志

调用函数OSFlagPost()可以对事件标志组进行置位或清零，函数原型如下：

```c
OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,                    //指向事件标志组
                      OS_FLAGS      flags,                    //决定对哪些位清零和置位
                      OS_OPT        opt,                    //决定对标志位的操作
                      OS_ERR       *p_err)
{
    OS_FLAGS  flags_cur;
    CPU_TS    ts;
 
    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 
    flags_cur = OS_FlagPost(p_grp,
                            flags,
                            opt,
                            ts,
                            p_err);
 
    return (flags_cur);
}
```

flags：决定对哪些位清零和置位，当opt参数为OS_OPT_POST_FLAG_SET的时，参数flags中置位的位就会在事件标志组中对应的位也将被置位；当opt为OS_OPT_POST_FLAG_CLR的时候参数flags中置位的位在事件标志组中对应的位将被清零。

opt：决定对flags选定的标志位的操作，有两种选项可供选择。OS_OPT_POST_FLAG_SET：对标志位进行置位操作；OS_OPT_POST_FLAG_CLR：对标志位进行清零操作。

这个函数的返回值时当前的flags值，通过该返回值，可以查到此时本任务在flags中的哪一个位有没有被置位，或者其他还有哪些任务在flags中的标志。

一般情况下，需要进行置位或者清零的标志由一个掩码确定（参数flags）。OSFlagPost()修改完事件标志后，将检查并使那些等待条件已经满足的任务进入就绪态。该函数可以对已经置位或清零的标志进行重复置位和清零操作。
