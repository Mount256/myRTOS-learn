在uC/OS-III中，**事件标志组（Event Flags Group）** 用于实现多任务基于多个事件状态的同步，支持“逻辑与（AND）”和“逻辑或（OR）”触发机制。以下是事件标志组的使用流程及关键操作：

---

### 🔧 **一、事件标志组使用流程**
1. **创建事件标志组**  
   - 定义事件标志组结构体 `OS_FLAG_GRP`，并调用 `OSFlagCreate()` 初始化：  
     ```c
     OS_FLAG_GRP flag_grp;  // 声明事件标志组
     OS_ERR err;
     OSFlagCreate(&flag_grp, "EventGroup", 0, &err); // 初始标志位全0
     ```
   - **参数说明**：  
     - `flags`：初始标志值（通常设为0，表示无事件发生）。

2. **任务等待事件**  
   - 任务调用 `OSFlagPend()` 挂起自身，等待指定事件组合：  
     ```c
     #define EVENT_A (0x01 << 0)  // 事件A掩码（位0）
     #define EVENT_B (0x01 << 1)  // 事件B掩码（位1）
     
     OS_FLAGS flags_rdy = OSFlagPend(
         &flag_grp, 
         EVENT_A | EVENT_B,    // 等待位0和位1
         100,                  // 超时时间（时钟节拍）
         OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_BLOCKING, // 等待所有事件置位
         NULL, &err
     );
     ```
   - **关键选项**：  
     - `OS_OPT_PEND_FLAG_SET_ALL`：需所有指定事件置位（AND逻辑）。  
     - `OS_OPT_PEND_FLAG_SET_ANY`：任意事件置位即触发（OR逻辑）。  
     - `OS_OPT_PEND_FLAG_CONSUME`：事件触发后自动清零标志位。

3. **发布事件**  
   - 在任务或中断服务程序（ISR）中调用 `OSFlagPost()` 设置事件标志：  
     ```c
     // 设置EVENT_A标志位
     OSFlagPost(&flag_grp, EVENT_A, OS_OPT_POST_FLAG_SET, &err);
     ```
   - **选项说明**：  
     - `OS_OPT_POST_FLAG_SET`：置位指定标志位。  
     - `OS_OPT_POST_FLAG_CLR`：清零指定标志位。

4. **删除事件标志组**  
   - 不再使用时调用 `OSFlagDel()` 释放资源（需启用宏 `OS_CFG_FLAG_DEL_EN`）：  
     ```c
     OSFlagDel(&flag_grp, OS_OPT_DEL_NO_PEND, &err);
     ```

---

### ⚠️ **二、关键注意事项**
1. **中断上下文限制**  
   - **ISR 仅能发布事件（`OSFlagPost()`）**，不可创建/删除标志组或等待事件。

2. **事件标志的特性**  
   - **无累计性**：重复设置同一事件位无效（位状态仅为0或1）。  
   - **无数据传递**：仅传递状态，需结合消息队列传输数据。

3. **超时处理**  
   - 若超时后事件未触发，`OSFlagPend()` 返回当前标志位值，需手动检查是否满足条件：  
     ```c
     if ((flags_rdy & (EVENT_A | EVENT_B)) == (EVENT_A | EVENT_B)) {
         // 事件满足条件
     }
     ```

---

### 🛠️ **三、典型应用场景**
#### 1. **多条件任务启动**  
   **场景**：设备启动需同时满足“电源就绪（位0） + 传感器校准完成（位1）”  
   ```c
   // 等待位0和位1均置位（AND逻辑）
   OSFlagPend(&flag_grp, POWER_READY | SENSOR_READY, 0, 
               OS_OPT_PEND_FLAG_SET_ALL, NULL, &err);
   ```

#### 2. **紧急事件响应**  
   **场景**：任一错误标志（位2/位3）置位即触发警报（OR逻辑）  
   ```c
   // 等待位2或位3置位
   OSFlagPend(&flag_grp, ERROR_FLAG1 | ERROR_FLAG2, 0,
               OS_OPT_PEND_FLAG_SET_ANY, NULL, &err);
   ```

#### 3. **按键组合检测**  
   **场景**：检测KEY1与KEY2同时按下（实验示例）：  
   ```c
   void Key_Task() {
       if (KEY1按下) OSFlagPost(&flag_grp, KEY1_EVENT, OS_OPT_POST_FLAG_SET, &err);
       if (KEY2按下) OSFlagPost(&flag_grp, KEY2_EVENT, OS_OPT_POST_FLAG_SET, &err);
   }
   
   void Monitor_Task() {
       // 等待KEY1和KEY2均置位
       OSFlagPend(&flag_grp, KEY1_EVENT | KEY2_EVENT, 0, 
                  OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME, NULL, &err);
       printf("双键按下！");
   }
   ```

---

### 📌 **四、与信号量的对比**
| **特性**         | **事件标志组**                  | **信号量**                |
|------------------|-------------------------------|--------------------------|
| 同步逻辑         | 支持多事件AND/OR组合            | 单计数器（无组合逻辑）      |
| 资源管理         | ❌ 仅同步状态                  | ✅ 管理资源数量（如缓冲区） |
| 适用场景         | 多事件复杂条件触发              | 单事件同步或资源计数        |

---

### 💎 **总结**
1. **事件用于多条件同步**：通过位掩码组合事件，支持灵活AND/OR逻辑。  
2. **核心操作**：创建→等待→发布→销毁，注意ISR仅能发布事件。  
3. **典型场景**：多传感器就绪检查、复合错误检测、按键组合触发等。  
4. **优化建议**：使用 `OS_OPT_PEND_FLAG_CONSUME` 避免重复触发，超时后需手动验证事件状态。  

> 示例代码可参考：[UCOSIII事件标志组实验设计](https://blog.csdn.net/YinShiJiaW/article/details/100988337)。