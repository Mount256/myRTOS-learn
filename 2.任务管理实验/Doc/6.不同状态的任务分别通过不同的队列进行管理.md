在uC/OS-III中，任务状态（就绪、挂起、等待、延时）通过不同的队列结构进行管理，这些队列与任务控制块（TCB）协作实现高效的任务调度和资源同步。以下是各状态对应的队列管理机制详解：

---

### ⏱️ 一、就绪态（Ready）
就绪任务被组织在**就绪列表（Ready List）**中，采用双层数据结构实现高效调度：
1. **优先级位图（OSPrioTbl）**  
   - 一个位映射表（Bit-map），每个位对应一个优先级（0为最高优先级）。  
   - 当某优先级下有就绪任务时，对应位置置1，通过 `OS_PrioGetHighest()` 在O(1)时间内找到最高优先级任务。  
2. **就绪队列（OSRdyList[]）**  
   - 每个优先级对应一个双向链表，存储同优先级的所有就绪任务TCB。  
   - 链表通过TCB的 `NextPtr` 和 `PrevPtr` 字段链接，支持快速插入（`OS_RdyListInsert()`）和移除（`OS_RdyListRemove()`）。  
3. **时间片轮转**  
   - 同优先级任务共享CPU时间片，由系统节拍中断递减时间片计数器（`TimeQuantaCtr`），归零后任务移至链表尾部，下一任务运行。

---

### ⏸️ 二、挂起态（Suspended）
挂起任务**不进入任何队列**，仅通过TCB状态标识管理：  
1. **挂起计数器（`SuspendCtr`）**  
   - 任务每被挂起一次（`OSTaskSuspend()`），计数器递增；需恢复相同次数（`OSTaskResume()`）才能重回就绪态。  
2. **状态标识（`TaskState`）**  
   - TCB的 `TaskState` 字段标记为 `OS_TASK_STATE_SUSPENDED`，并从就绪队列移除。  
3. **恢复机制**  
   - 当 `SuspendCtr` 归零时，任务重新插入就绪队列（若未被阻塞或延时）。

---

### 🕰️ 三、等待态（Waiting / Blocked）
等待任务关联到**内核对象的等待队列**（如信号量、消息队列）：  
1. **等待队列结构**  
   - 每个内核对象（如 `OS_SEM`、`OS_Q`）包含一个 `OS_PEND_LIST` 双向链表，存储等待该对象的任务TCB。  
2. **优先级排序**  
   - 等待任务按优先级降序排列，高优先级任务优先获取资源。  
3. **超时机制**  
   - 若任务指定超时时间（如 `OSQPend(timeout)`），会同时被插入延时队列（`OSTickList`），超时后自动唤醒并返回错误码。

---

### ⏳ 四、延时态（Delayed）
延时任务由**系统节拍中断**管理的 **延时队列（OSTickList）** 处理：  
1. **延时队列结构**  
   - 双向链表按到期时间戳（`TS`）升序排列，节点包含TCB指针和到期时间。  
2. **到期唤醒**  
   - 每次系统节拍中断（`OSTimeTick()`）检查链表头部：  
     - 若 `TS ≤ OSTickCtr`（当前时间），将任务移回就绪队列并更新状态为 `OS_TASK_STATE_RDY`。  
   - 未到期任务保留在链表中。  
3. **绝对时间戳**  
   - 任务的延时到期时间 `TS = OSTickCtr + delay_ticks`，存储在TCB中。

---

### 🔄 五、状态转换与队列联动
| **操作**               | **队列变化**                                                                 |
|------------------------|-----------------------------------------------------------------------------|
| 任务创建（`OSTaskCreate()`） | 插入就绪队列（`OSRdyList`）和优先级位图。                           |
| 任务延时（`OSTimeDly()`）   | 从就绪队列移除 → 插入延时队列（`OSTickList`）。                   |
| 等待事件（如 `OSQPend()`）   | 从就绪队列移除 → 插入内核对象等待队列（如 `OS_Q.PendList`）。      |
| 事件到达（如 `OSQPost()`）   | 从内核对象等待队列移除 → 插入就绪队列（若任务无其他阻塞）。         |

---

### ⚙️ 六、设计特点与性能优化
1. **O(1)调度复杂度**  
   - 优先级位图+双向链表实现快速最高优先级任务查找。  
2. **零内存拷贝**  
   - 队列操作仅移动TCB指针，不复制任务数据。  
3. **动态超时管理**  
   - 延时队列按时间排序，节拍中断仅需检查链表头部任务。  
4. **临界区保护**  
   - 队列操作通过 `CRITICAL_ENTER()` 屏蔽中断，避免并发冲突。

通过上述机制，uC/OS-III在有限资源下实现了高实时性任务管理，开发者需合理设计任务优先级和超时策略以优化系统性能。