在 **uC/OS-III** 中，消息队列的内部实现是一个精心设计的**链式数据结构**，主要由三个关键部分组成。下面将从源码层面解析其构成：

### 1. 核心数据结构
#### (1) **消息队列控制块 (OS_Q)**
```c
// os.h 中定义
struct os_q {
    OS_OBJ_TYPE          Type;            // 对象类型标识 (OS_OBJ_TYPE_Q)
    CPU_CHAR            *NamePtr;         // 队列名称
    OS_PEND_LIST         PendList;        // 等待消息队列的任务链表
    OS_MSG_Q             MsgQ;            // ⭐️ 消息存储核心单元（见下文）
};
```

这里等待队列的作用是：在某个任务想要从 OS_Q 中获取消息消息时，如果 OS_Q 为空，则该任务被插入到PendList中排队，等待 OS_Q 中消息的到来；当某个任务想要向 OS_Q 发布消息时，如果看到这个 OS_Q 的 PendList 中有任务在排队等待，则直接把消息给正在排队的任务。

#### (2) **消息容器 (OS_MSG)**
```c
struct os_msg {
    OS_MSG              *NextPtr;         // ⭐️ 指向下一条消息（链式结构）
    void                *MsgPtr;          // 消息数据指针
    OS_MSG_SIZE          MsgSize;         // 消息字节数
    CPU_TS               MsgTS;           // 时间戳（记录发送时间）
};
```

#### (3) **消息队列核心 (OS_MSG_Q)**

这个是消息队列的控制块。在某个任务想要向 OS_Q 发布消息时，如果当前没有任务在这个 OS_Q 上排队等消息，那么它就会把消息放到 OS_Q 的MsgQ中；当某个任务想要从 OS_Q 获取消息时，如果它发现 OS_Q 的 MsgQ 中有消息，那么就直接从 MsgQ 中取走消息。

```c
typedef struct os_msg_q {
    OS_MSG              *InPtr;           // ⭐️ 入口指针（新消息插入点）
    OS_MSG              *OutPtr;          // ⭐️ 出口指针（消息取出点）
    OS_MSG_QTY           NbrEntries;      // 队列中当前消息个数
    OS_MSG_QTY           NbrEntriesSize;  // 队列允许的最大消息个数
    OS_MSG_QTY           NbrEntriesMax;   // 历史峰值消息量
} OS_MSG_Q;
```

### 2. 内存中的物理结构
![](消息队列控制块.png)

这个控制块表明它记录了两种队列的指针，一种是等待队列，另一种是消息队列。

![](消息队列​.png)

### 3. 关键工作机制
#### ▶️ **队列初始化**
调用 `OSQCreate()` 时：
1. 分配 `OS_Q` 控制块
2. 初始化 `MsgQ`：
   - `InPtr = OutPtr = NULL`
   - `NbrEntries = 0`
   - `NbrEntriesSize = 用户指定容量`

#### ▶️ **发送消息 (OSQPost)**

大致流程如下：任务需要发送消息，那么它先要从消息池申请一个消息，然后发现该消息并没有其他任务等待，于是将其插入到消息队列中。

```c
void  OSQPost (OS_Q        *p_q,
               void        *p_void,
               OS_MSG_SIZE  msg_size,
               OS_OPT       opt)
{
    OS_MSG  *p_msg;
    
    // 1. 从全局消息池获取空闲 OS_MSG 单元
    p_msg = OS_MsgPoolGet(); // 内部操作：OSMsgPool.NextPtr
    
    // 2. 填充消息数据
    p_msg->NextPtr = NULL;
    p_msg->MsgPtr  = p_void;   // 存储用户数据指针
    p_msg->MsgSize = msg_size;
    p_msg->MsgTS   = OS_TS_GET();

    // 3. 插入队列
    if (p_q->MsgQ.NbrEntries == 0) { // 空队列
        p_q->MsgQ.OutPtr = p_msg;    // 首条消息
    } else {
        p_q->MsgQ.InPtr->NextPtr = p_msg; // 链入尾部
    }
    p_q->MsgQ.InPtr = p_msg;   // 更新入口指针

    // 4. 更新计数器
    p_q->MsgQ.NbrEntries++;
    if (p_q->MsgQ.NbrEntries > p_q->MsgQ.NbrEntriesMax) {
        p_q->MsgQ.NbrEntriesMax = p_q->MsgQ.NbrEntries;
    }
    
    // 5. 唤醒等待任务...
}
```

#### ▶️ **接收消息 (OSQPend)**

大致流程如下：任务从消息队列中发现了自己需要的消息，于是读完消息后将其释放回消息池中。

```c
void  *OSQPend (OS_Q         *p_q,
                OS_TICK       timeout,
                OS_OPT        opt,
                OS_MSG_SIZE  *p_msg_size,
                CPU_TS       *p_ts,
                OS_ERR       *p_err)
{
    OS_MSG  *p_msg;
    
    // 1. 检查队列非空
    if (p_q->MsgQ.NbrEntries > 0) {
        // 2. 取出头部消息 (FIFO)
        p_msg = p_q->MsgQ.OutPtr;
        
        // 3. 更新队列
        p_q->MsgQ.OutPtr = p_msg->NextPtr; // 下移出口指针
        if (p_q->MsgQ.InPtr == p_msg) {    // 最后一条消息
            p_q->MsgQ.InPtr = NULL;
        }
        p_q->MsgQ.NbrEntries--;
        
        // 4. 返回消息内容
        *p_msg_size = p_msg->MsgSize;
        if (p_ts != NULL) {
            *p_ts = p_msg->MsgTS;   // 返回时间戳
        }
        void *p_void = p_msg->MsgPtr;
        
        // 5. 归还 OS_MSG 到消息池
        OS_MsgPoolPut(p_msg);
        
        return p_void;
    } else {
        // 6. 无消息时挂起当前任务...
    }
}
```

### 4. 底层资源管理
#### ▶️ **全局消息池 (OSMsgPool)**
```c
// os_msg.c
OS_MSG        *OSMsgPoolNextPtr = NULL;   // 空闲链表头指针
OS_MSG_QTY     OSMsgPoolNbrFree = 0;      // 剩余可用消息单元

void  OS_MsgPoolInit (void) {
    // 1. 分配连续内存块 (通常位于 .bss 段)
    OS_MSG *p_msg = (OS_MSG*)&OSMsgPool[0];
    
    // 2. 构建单向链表
    for (i=0; i<OS_CFG_MSG_POOL_SIZE; i++) {
        p_msg->NextPtr = (OS_MSG*)(p_msg + 1);
        p_msg++;
    }
    p_msg--; 
    p_msg->NextPtr = NULL;  // 末尾置空
    
    // 3. 初始化全局指针
    OSMsgPoolNextPtr = (OS_MSG*)&OSMsgPool[0];
    OSMsgPoolNbrFree = OS_CFG_MSG_POOL_SIZE;
}
```

> 📌 **关键配置宏 (os_cfg.h)**：
> ```c
> #define OS_CFG_MSG_POOL_SIZE      100u   // 系统级消息单元总数
> #define OS_CFG_Q_EN               1u     // 启用队列功能
> ```
